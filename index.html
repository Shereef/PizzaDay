<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pizza Day Formatter</title>
  </head>
  <body>
    <h1>Pizza Day Formatter</h1>
    <h2>Select the school cash export:</h2>
    <br />
    <input type="file" id="excelFileInput" accept=".xlsx" />
    <br />
    <h2>List of Homeroom & Room Numbers.csv:</h2>
    <br />
    <input type="file" id="csvFileInput" accept=".csv" />
    <br />
    <br />
    <button onclick="process()">Process</button>
    <br />
    <br />
    <h3>Excel Columns:</h3>
    <br />
    <textarea id="excelColumns" style="height: 100px">
Choice Name
Homeroom
Quantity
Student Name</textarea
    >
    <br />
    <span
      >Choice name must be first<br />Home room must be second<br />Quantity
      must be third<br />Student Name must be fourth<br />
      This is used to set the column names if they ever change<br />You
      shouldn't need to change this</span
    >
    <br />

    <br />
    <br />
    <h3>CSV Columns:</h3>
    <br />
    <textarea id="csvColumns" style="height: 100px">
Home Room Name
Location
Room Number</textarea
    >
    <br />
    <span
      >Home room name must be the first column<br />Location must be the second
      column<br />Room Number must be the third column This is used to set the
      column names if they ever change<br />You shouldn't need to change
      this</span
    >
    <br />

    <br />
    <br />

    <script>
      const excelChoiceNameIndex = 0;
      const excelHomeRoomIndex = 1;
      const excelQuantityIndex = 2;

      const csvHomeRoomIndex = 0;
      const csvLocationIndex = 1;
      const csvRoomNumberIndex = 2;
      function getColumnsToKeep() {
        const columnsToKeep = document
          .getElementById("excelColumns")
          .value.trim()
          .split("\n")
          .filter((element) => element?.trim().length);

        return columnsToKeep;
      }
      function getCSVColumns() {
        const csvColumns = document
          .getElementById("csvColumns")
          .value.trim()
          .split("\n")
          .filter((element) => element?.trim().length);
        return csvColumns;
      }
      function process() {
        const columnsToKeep = getColumnsToKeep();
        const columnToFind = columnsToKeep[excelChoiceNameIndex];

        const excelFileInput = document.getElementById("excelFileInput");
        const excelFile = excelFileInput.files[0];
        const csvFileInput = document.getElementById("csvFileInput");
        const csvFile = csvFileInput.files[0];
        if (!excelFile || !csvFile) {
          alert("Please select both Excel and CSV files.");
          return;
        }

        const reader = new FileReader();

        reader.onload = function (e) {
          const arrayBuffer = e.target.result;

          let workbook;
          try {
            workbook = XLSX.read(arrayBuffer, { type: "array" });
          } catch (error) {
            alert(
              "An error occurred while processing the file:",
              error.message
            );
            return;
          }

          const sheetNames = workbook.SheetNames;

          // Prompt the user to select a sheet by number
          let promptMessage = "Select a sheet by number:\n";
          sheetNames.forEach((sheetName, index) => {
            promptMessage += `${index + 1}. ${sheetName}\n`;
          });

          const selectedSheetIndex = parseInt(prompt(promptMessage, 2));

          if (
            isNaN(selectedSheetIndex) ||
            selectedSheetIndex < 1 ||
            selectedSheetIndex > sheetNames.length
          ) {
            alert("Invalid sheet number selected.");
            return;
          }

          const selectedSheet = sheetNames[selectedSheetIndex - 1]; // Adjust for 0-based index

          const worksheet = workbook.Sheets[selectedSheet];

          // Convert the worksheet data to an array of arrays
          const sheetData = XLSX.utils.sheet_to_json(worksheet, {
            header: 1,
            range: 0, // Start from the beginning of the sheet
          });

          // Find the index of the row with the specified value in the desired column
          const rowIndex = sheetData.findIndex((row) =>
            row.includes(columnToFind)
          );

          if (rowIndex === -1) {
            alert("The specified column value was not found.");
            return;
          }

          // The number of rows to skip is the row index where the value was found
          const rowsToSkip = rowIndex + 1; // Add 1 to account for the header row

          console.log("Rows to skip:", rowsToSkip);

          // The header is the row where the value was found
          const header = sheetData[rowIndex];

          // Filter out unwanted columns while keeping the desired ones
          let filteredData = sheetData
            .slice(rowsToSkip)
            .filter((row) => {
              return row.length && row.some((cell) => cell);
            })
            .map((row) => {
              return columnsToKeep.map((col) => row[header.indexOf(col)]);
            })
            .filter((row) => {
              return row.length && row.some((cell) => cell);
            });
          let choice;
          for (const row of filteredData) {
            const rowChoice = row[excelChoiceNameIndex];
            if (rowChoice) {
              choice = rowChoice;
            } else {
              row[excelChoiceNameIndex] = choice;
            }
          }
          filteredData = filteredData.filter((row) => {
            return row.every((cell) => cell);
          });
          // Sort the data by 'Homeroom' (assuming 'Homeroom' is a string)
          filteredData.sort((a, b) => {
            const homeroomA = a[excelHomeRoomIndex] || "";
            const homeroomB = b[excelHomeRoomIndex] || "";
            return homeroomA.localeCompare(homeroomB);
          });
          console.log("Header:", columnsToKeep);
          console.log("Filtered Data (sorted by Homeroom):", filteredData);

          filteredData.unshift(columnsToKeep);

          // Read and process the CSV file
          const csvReader = new FileReader();
          csvReader.onload = function (csvEvent) {
            const csvText = csvEvent.target.result;
            const csvData = CSVToArray(csvText);

            // Merge data based on 'Home Room Name'
            const mergedData = mergeData(filteredData, csvData);

            // Export the merged data to a new Excel file
            exportMergedData(mergedData);
          };
          csvReader.readAsText(csvFile);
        };

        reader.readAsArrayBuffer(excelFile);
      }

      // Function to merge data based on 'Home Room Name'
      function mergeData(excelData, csvData) {
        const columnsToKeep = getColumnsToKeep();
        const csvColumns = getCSVColumns();

        const excelHomeRoomNameIndex = excelData[0].indexOf(
          columnsToKeep[excelHomeRoomIndex]
        );
        const csvHomeRoomNameIndex = csvData[0].indexOf(
          csvColumns[csvHomeRoomIndex]
        );

        if (excelHomeRoomNameIndex === -1 || csvHomeRoomNameIndex === -1) {
          alert("Home Room not found in Excel or CSV data.");
          return;
        }
        const csvHeader = csvData[0];
        const csvHeaderWithoutHomeRoomName = csvHeader.filter(
          (col) => col !== csvHeader[csvHomeRoomNameIndex]
        );
        const mergedData = excelData.map((row, index) => {
          if (index === 0) {
            return [...row, ...csvHeaderWithoutHomeRoomName];
          } else {
            const csvHomeRoomName = row[excelHomeRoomNameIndex];
            const matchingCsvRow = csvData.find(
              (csvRow) => csvRow[csvHomeRoomNameIndex] === csvHomeRoomName
            );
            if (matchingCsvRow) {
              const resultRow = [
                ...row,
                ...matchingCsvRow.filter(
                  (col) => matchingCsvRow.indexOf(col) !== csvHomeRoomNameIndex
                ),
              ];
              return resultRow;
            } else {
              return row;
            }
          }
        });

        return mergedData;
      }

      // Function to export merged data to a new Excel file
      function exportMergedData(mergedData) {
        const newWorkbook = XLSX.utils.book_new();
        const newWorksheet = XLSX.utils.aoa_to_sheet(mergedData);
        XLSX.utils.book_append_sheet(newWorkbook, newWorksheet, "MergedData");

        // Write the workbook to a binary string and create a Blob
        const outputData = XLSX.write(newWorkbook, {
          bookType: "xlsx",
          type: "binary",
        });
        const blob = new Blob([s2ab(outputData)], {
          type: "application/octet-stream",
        });

        // Function to convert string to ArrayBuffer
        function s2ab(s) {
          const buf = new ArrayBuffer(s.length);
          const view = new Uint8Array(buf);
          for (let i = 0; i < s.length; i++) view[i] = s.charCodeAt(i) & 0xff;
          return buf;
        }

        // Create a download link and trigger a click event to prompt for download
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = "merged_data.xlsx";
        link.click();
      }

      // Custom function to parse CSV data
      function CSVToArray(strData, strDelimiter) {
        strDelimiter = strDelimiter || ",";

        const objPattern = new RegExp(
          "(\\" +
            strDelimiter +
            "|\\r?\\n|\\r|^)" +
            '(?:"([^"]*(?:""[^"]*)*)"|' +
            '([^"\\' +
            strDelimiter +
            "\\r\\n]*))",
          "gi"
        );

        const arrData = [[]];
        let arrMatches = null;

        while ((arrMatches = objPattern.exec(strData))) {
          const strMatchedDelimiter = arrMatches[1];

          if (
            strMatchedDelimiter.length &&
            strMatchedDelimiter !== strDelimiter
          ) {
            arrData.push([]);
          }

          let strMatchedValue;
          if (arrMatches[2]) {
            strMatchedValue = arrMatches[2].replace(new RegExp('""', "g"), '"');
          } else {
            strMatchedValue = arrMatches[3];
          }
          arrData[arrData.length - 1].push(strMatchedValue);
        }

        return arrData;
      }
    </script>

    <!-- Include xlsx library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.16.9/xlsx.full.min.js"></script>
  </body>
</html>
